<?php
/**
 * @file
 *   The Lexicon module is used to create lists of terms and definitions to use on a website and optionally
 *   mark those terms in the content of the website with a configurable indicator.
 *
 *   The Lexicon module lists all lexicon terms on a lexicon page. Optionally it scans posts for
 *   lexicon terms (and their synonyms) in the body. If found, the lexicon indicator is inserted
 *   after the term, or the term is turned into an indicator link depending on the settings. By
 *   hovering over the indicator, users may learn the definition of that term. Clicking leads the
 *   user to that term presented within the whole lexicon.
 */

/**
 * Implements hook_help().
 */
function lexicon_help($path, $args = array()) {
  $output = '';

  switch ($path) {
    case 'admin/help#lexicon':
      return t('<p>Lexicon is used to create lists of terms and definitions to use on a website and optionally mark and link them in the content with an indicator</p>
      <p>The Lexicon module lists all terms within a vocabulary on a lexicon page. Optionally it scans posts for lexicon terms (and their synonyms) in the body. If found, the lexicon indicator is inserted after the term, or the term is turned into an indicator link depending on the settings. By hovering over the indicator, users may learn the definition of that term. Clicking leads the user to that term presented within the whole lexicon.</p>
      <p>Lexicon terms are managed in vocabularies within the taxonomy module. To get started with lexicon, create a new vocabulary on the !taxonomy_admin page. The vocabulary need not be associated with any modules. Add a few terms to the vocabulary. The term title should be the lexicon entry and the description should be its definition. You can use the related terms, synonyms, and image features by adding fields to the vocabulary using the Fields functionality of Drupal 7. For synonyms create a Field of type "Text". For related terms create a field of type "Term reference". For images create a field of type "Image". You can configure which field to use as the field for related terms, synonyms and images in the Lexicon configuration. These features impact the display of the lexicon when viewed in an overview.</p>
      <p>Next, you have to set up the Lexicon module by selecting the vocabularies that you want to use as Lexicons and set the behaviour of the module to your preferences. You have to enable the Lexicon filter on input formats if you want terms to be marked in the content. On the !input_formats page, select a text format to configure. Select the Lexicon filter checkbox and press "Save configuration".</p>
      <p>Administration of lexicon requires %permissions permissions.</p>',
      array('%permissions' => join(', ',
        array(t('administer taxonomy'), t('access administration pages'), t('administer lexicon'))),
        '!taxonomy_admin' => l(t('administer >> content >> taxonomy'), 'admin/structure/taxonomy'),
        '!input_formats' => l(t('administer >> site configuration >> input formats'), 'admin/config/content/formats'),
        '!lexicon' => l(t('administer >> site configuration >> lexicon'), 'admin/config/system/lexicon'),
        '!lexicons' => l(t('lexicons'), 'lexicon')));
      break;

    case 'admin/config/system/lexicon':
      return '<p><big>' . t('This page and its tabs allow you to control how the Lexicon module functions.') . '</big></p>';
      break;

    case 'admin/modules#description':
      return t('Maintain one or more lexicons on your site.');
      break;

    case 'lexicon':
      if (!$args[1]) {
        if (user_access('administer lexicon')) {
          return t('<a href="!url">Lexicon settings page</a>', array('!url' => url('admin/config/system/lexicon')));
        }
      }
      break;
  }
}

/**
 * Implements hook_block_info().
 */
function lexicon_block_info() {
  $blocks = array();
  $blocks['lexicon_random_term'] = array(
    'info' => t('Lexicon random term block'),
  );
  return $blocks;
}

/**
 * Implements hook_block_configure().
 */
function lexicon_block_configure($delta) {
  $form = array();
  switch ($delta) {
    case 'lexicon_random_term':
      $vids = array();
      // Get all vocabulary id's that are used as Lexicons from the lexicon setting
      $vid_list = variable_get('lexicon_vids', array());
      foreach ($vid_list as $vid) {
      // Somehow if the vocabulary is not checked on the settings page, Drupal still returns 0 in the array so when the $vid != 0 we have a vocabulary that is used as a Lexicon.
        if ($vid != 0) {
          // Load the vocabulary to get the human readable name to put use in the options in the form
          $voc = taxonomy_vocabulary_load($vid);
          $vids[$vid] = check_plain($voc->name);
        }
      }
      $form['vids'] = array(
        '#type' => 'checkboxes',
        '#title' => t('Choose from'),
        '#description' => t('Select the vocabularies to choose a term from.'),
        '#options' => $vids,
        '#default_value' => variable_get("lexicon_block_{$delta}_vids", array()),
        '#prefix' => '<div class="lexicon_checkboxes">',
        '#suffix' => '</div>',
      );

      $form['interval'] = array(
        '#type' => 'textfield',
        '#size' => 4,
        '#maxlength' => 3,
        '#default_value' => variable_get("lexicon_block_{$delta}_interval", 0),
        '#field_prefix' => '<strong>' . t('Update every') . '</strong>&nbsp;',
        '#prefix' => '<div class="container-inline lexicon-interval">',
      );

      $form['step'] = array(
        '#type' => 'select',
        '#default_value' => variable_get("lexicon_block_{$delta}_step", 0),
        '#options' => array(
          1 => t('seconds'),
          60 => t('minutes'),
          3600 => t('hours'),
          86400 => t('days'),
        ),
        '#suffix' => '</div>',
        '#description' => t('How often do you want a new term? Leaving this blank or zero means every time.'),
      );

      $form['link'] = array(
        '#type' => 'checkbox',
        '#title' => t('Show term as link'),
        '#default_value' => variable_get("lexicon_block_{$delta}_link", TRUE),
        '#description' => t('If selected, this option causes the term name to be made a link to the lexicon entry.'),
      );

      return $form;
  }
}

/**
 * Implements hook_block_save().
 */
function lexicon_block_save($delta, $edit) {
  switch ($delta) {
    case 'lexicon_random_term':
      variable_set("lexicon_block_{$delta}_vids", $edit['vids']);
      if (!$edit['interval'] || !is_numeric($edit['interval'])) {
        // Make interval numeric;
        $edit['interval'] = 0;
      }
      variable_set("lexicon_block_{$delta}_interval", $edit['interval']);
      variable_set("lexicon_block_{$delta}_step", $edit['step']);
      variable_set("lexicon_block_{$delta}_link", $edit['link']);
      break;
  }
}

/**
 * Implements hook_block_view().
 */
function lexicon_block_view($delta) {
  switch ($delta) {
    case 'lexicon_random_term':
      $interval = variable_get("lexicon_block_{$delta}_interval", 0) * variable_get("lexicon_block_{$delta}_step", 0);
      $last = variable_get("lexicon_block_{$delta}_last", 0);
      // Check if the configured interval time to refresh the random term has passed
      if ($last + $interval < REQUEST_TIME) {
        // Time to get a new selection.
        $saved_vids = variable_get("lexicon_block_{$delta}_vids", NULL);
        // Check if the block is configured.
        if (is_null($saved_vids)) {
          $blocks['content'] = t('Lexicon block !blockid has not been configured.', array('!blockid' => $delta));
          return $blocks;
        }
        $vids = array_filter($saved_vids);
        if (count($vids) == 0) {
          $vids = variable_get('lexicon_vids', array());
        }

        // Retrieve a random term from one of the vocabularies
        $query = db_select('taxonomy_term_data', 'ttd');
        $query->fields('ttd', array('tid', 'vid'));

        $query->condition('ttd.vid', $vids, 'IN')
          ->orderBy('RAND()')
          ->range(0, 1);
        $result = $query->orderRandom()->execute()->fetch();

        $tid = $result->tid;
        $vid = $result->vid;

        // Set "now" as the last selection time and save that tid and vid.
        variable_set("lexicon_block_{$delta}_last", REQUEST_TIME);
        variable_set("lexicon_block_{$delta}_tid", $tid);
        variable_set("lexicon_block_{$delta}_vid", $vid);
      }
      else {
        // Get the current selected tid.
        $tid = variable_get("lexicon_block_{$delta}_tid", 0);
        $vid = variable_get("lexicon_block_{$delta}_vid", 0);
      }

      $link = variable_get("lexicon_block_{$delta}_link", TRUE);
      $term = taxonomy_term_load($tid);
      $term = _lexicon_term_add_info($term);

      // If the block is configured not to link terms remove the link information.
      if (!$link) {
        unset($term->link);
      }

      // Call the theme hook
      $blocks['content'] = theme('lexicon_block_term',
      array(
        'term' => $term,
      ));

      return $blocks;
  }
}

/**
 * Implements hook_menu().
 */
function lexicon_menu() {
  // To provide a menu-item for each vocabulary that is configured to be used as a Lexicon get all the configured vocabulary id's
  $vids = array();
  $vids = variable_get('lexicon_vids', array());

  // Create a menu item for each vocabulary based on the configured path and title
  foreach ($vids as $vid) {
    //Don't create menu items for vocabularies that are not setup as being Lexicon vocabularies
    if ($vid != 0) {
      $lexicon_path = variable_get('lexicon_path_' . $vid, 'lexicon/' . $vid);
      $lexicon_title = variable_get('lexicon_title_' . $vid, t('Lexicon'));
      $items[$lexicon_path] = array(
        'title' => $lexicon_title,
        'page callback' => '_lexicon_page',
        'access arguments' => array('access lexicon'),
        'type' => MENU_SUGGESTED_ITEM,
        'file' => 'lexicon.pages.inc',
      );
    }
  }

  $items['admin/config/system/lexicon'] = array(
    'title' => 'Lexicon Settings',
    'page callback' => 'lexicon_settings_page',
    'description' => 'Select how you want the Lexicon module to behave.',
    'access arguments' => array('administer lexicon'),
    'type' => MENU_NORMAL_ITEM,
    'file' => 'lexicon.admin.inc',
    );

  $items['admin/config/system/lexicon/general'] = array(
    'title' => 'General',
    'description' => 'General settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lexicon_general_settings_form'),
    'access arguments' => array('administer lexicon'),
    'type' => MENU_DEFAULT_LOCAL_TASK,
    'weight' => -5,
    'file' => 'lexicon.admin.inc',
    );

  $items['admin/config/system/lexicon/paths_and_titles_and_intros'] = array(
    'title' => 'Paths, titles and intros',
    'description' => 'Paths, titles and intros settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lexicon_paths_and_titles_and_intros_form'),
    'access arguments' => array('administer lexicon'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 0,
    'file' => 'lexicon.admin.inc',
    );

$items['admin/config/system/lexicon/related_terms_synonyms_and_image'] = array(
    'title' => 'Related terms, synonyms and image',
    'description' => 'Related terms, synonyms and image settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lexicon_related_terms_and_synonyms_and_image_form'),
    'access arguments' => array('administer lexicon'),
    'type' => MENU_LOCAL_TASK,
    'weight' => 0,
    'file' => 'lexicon.admin.inc',
    );

  $items['admin/config/system/lexicon/alphabet'] = array(
    'title' => 'Alphabet',
    'access arguments' => array('administer lexicon'),
    'page callback' => 'drupal_get_form',
    'page arguments' => array('lexicon_alphabet_form'),
    'description' => 'Alphabet settings.',
    'type' => MENU_LOCAL_TASK,
    'weight' => -3,
    'file' => 'lexicon.admin.inc',
    );

  return $items;
}

/**
 * Implements hook_permission().
 */
function lexicon_permission() {
  return array(
    'administer lexicon' => array(
      'title' => t('Administer lexicon'),
      'description' => t('Perform maintenance tasks for Lexicon module'),
    ),
    'access lexicon' => array(
      'title' => t('Access lexicon'),
      'description' => t('Access the Lexicon page'),
    ),
  );
}

/**
 * Implements hook_theme().
 */
function lexicon_theme($existing, $type, $theme, $path) {
  return array(
    'lexicon_alphabar' => array(
      'template' => 'lexicon-alphabar',
      'variables' => array('lexicon_alphabar' => NULL),
      ),
    'lexicon_overview' => array(
      'template' => 'lexicon-overview',
      'variables' => array('lexicon_overview' => NULL, 'lexicon_alphabar' => NULL, 'lexicon_overview_sections' => NULL),
      ),
    'lexicon_overview_section' => array(
      'template' => 'lexicon-overview-section',
      'variables' => array('lexicon_section' => NULL, 'lexicon_overview_items' => NULL),
      ),
    'lexicon_overview_item' => array(
      'template' => 'lexicon-overview-item',
      'variables' => array('term' => NULL),
      ),
    'lexicon_block_term' => array(
      'template' => 'lexicon-block-term',
      'variables' => array('term' => NULL),
      ),
    'lexicon_mark_term' => array(
      'template' => 'lexicon-mark-term',
      'variables' => array('term' => NULL, 'text' => NULL),
      ),
    );
}

/**
 * Implements hook_init().
 */
function lexicon_init() {
  $path = drupal_get_path('module', 'lexicon');
  // Load the lexicon.css on every page to style marked terms in the content
  drupal_add_css($path . '/css/lexicon.css');
}

/**
 * Implements hook_taxonomy_term_insert().
 */
function lexicon_taxonomy_term_insert($term) {
  _lexicon_clear_filter_cache($term->vid, FALSE);
}

/**
 * Implements hook_taxonomy_term_update().
 */
function lexicon_taxonomy_term_update($term) {
  _lexicon_clear_filter_cache($term->vid, FALSE);
}

/**
 * Implements hook_form_user_profile_form_alter().
 */
function lexicon_form_user_profile_form_alter(&$form, &$form_state, $form_id) {
  // If Lexicon is configured so that users can indicate if they want to have terms marked in the content then add the checkbox to the user profile edit form.
  if (variable_get('lexicon_disable_indicator', FALSE)) {
    $account = $form['#user'];
    $form['content_lexicon'] = array(
      '#type' => 'fieldset',
      '#title' => t('Lexicon Indicators'),
    );
    $form['content_lexicon']['lexicon_disable_indicator'] = array(
      '#type' => 'checkbox',
      '#title' => t('Disable Lexicon indicators'),
      '#return_value' => 1,
      '#default_value' => isset($account->data['lexicon_disable_indicator']) ? $account->data['lexicon_disable_indicator'] : 1,
      '#description' => t('Check this box to disable the display of Lexicon indicators.'),
    );
    return $form;
  }
}

/**
 * Implements hook_user_presave().
 */
function lexicon_user_presave(&$edit, $account, $category) {
  // Save the lexicon_disable_indicator setting when the user profile edit form is submitted.
  if (isset($edit['lexicon_disable_indicator'])) {
    $edit['data']['lexicon_disable_indicator'] = $edit['lexicon_disable_indicator'];
  }
}

/**
 * Implements hook_filter_info().
 */
function lexicon_filter_info() {
  $filters['filter_lexicon'] = array(
    'title' => t('Lexicon filter'),
    'description' => t('Maintain one or more lexicons on your site.'),
    'process callback' => '_filter_lexicon',
    'tips callback' => '_filter_lexicon_tips',
    'cache' => FALSE,
    'weight' => 50,
  );
  return $filters;
}

/**
* Implements hook_entity_info_alter() to add the Lexicon view mode (for future use).
*/
/*function lexicon_entity_info_alter(&$entity_info) {
  $entity_info['taxonomy_term']['view modes']['lexicon'] = array(
    'label' => t('Lexicon'),
    'custom settings' => FALSE,
  );
}*/

/**
* Implements hook_preprocess_node(). (for future use)
*/
/*function lexicon_preprocess_taxonomy_term(&$vars) {
  if($vars['view_mode'] == 'lexicon') {
    $vars['theme_hook_suggestions'][] = 'taxonomy_term__' . $vars['type'] . '__lexicon';
  }
}*/

/**
 * Filter tips callback function
 */
function _filter_lexicon_tips($filter, $format, $long = FALSE) {
  $block_tags = array();
  $blocking_tags_setting = variable_get("lexicon_blocking_tags", 'abbr acronym');
  if ($blocking_tags_setting != '') {
    $block_tags = explode(' ', $blocking_tags_setting);
  }
  $standard_blocks = array('a');
  foreach ($standard_blocks as $tag) {
    if (!in_array($tag, $block_tags)) {
      $block_tags[] = check_plain($tag);
    }
  }
  foreach ($block_tags as $key => $tag) {
    if ($tag[0] == '.') {
      $block_tags[$key] = 'span class="' . check_plain(drupal_substr($tag, 1)) . '"';
    }
  }

  sort($block_tags, SORT_STRING);
  $blocked = implode(', ', $block_tags);
  $more = ' ' . t('Additionally, these HTML elements will not be scanned: %blocked.', array('%blocked' => $blocked));

  if ($long) {
    return t('The Lexicon module will automatically mark terms that have been defined in the lexicon vocabulary with links to their descriptions. These marks depend on the settings and may be a superscript character or an icon, or the term may be turned into an acronym, cite, or abbreviation. If there are certain phrases or sections of text that should be excluded from lexicon marking and linking, use the special markup, [no-lexicon] ... [/no-lexicon].') . $more;
  }
  else {
    return t('Lexicon terms will be automatically marked with links to their descriptions. If there are certain phrases or sections of text that should be excluded from lexicon marking and linking, use the special markup, [no-lexicon] ... [/no-lexicon].') . $more;
  }
}

/**
 * Lexicon filter process callback function.
 * Marks terms in the content of the website.
 */
function _filter_lexicon($text, $filter, $format) {
  global $user;
  // If the Lexicon is setup so that users can indicate if they want terms to be marked and the current user has indicated that they do not want terms to be marked return the text as is.
  if (variable_get('lexicon_disable_indicator', FALSE)) {
    if (isset($user->data['lexicon_disable_indicator'])) {
      if ($user->data['lexicon_disable_indicator'] == 1) {
        return $text;
      }
    }
  }

  $current_term = 0;
  // If the current page is a taxonomy term page then set $current_term.
  if (strcmp(arg(0), 'taxonomy') == 0 && strcmp(arg(1), 'term') == 0 && arg(2) > 0) {
    $current_term = arg(2);
  }

  // If marking of terms is enabled then mark terms and synonyms.
  if (variable_get("lexicon_mark_terms", 0) == 1 ) {
    $text = ' ' . $text . ' ';
    $replace_mode = variable_get("lexicon_replace", 'superscript');
    $link_style = variable_get("lexicon_link", 'normal');
    $absolute_link = ($link_style == 'absolute');
    $vids = variable_get('lexicon_vids', array());
    $terms = _lexicon_get_terms($vids);
    $terms_replace = array();
    $tip_list = array();

    if (is_array($terms)) {
      foreach ($terms as $term) {
        // If the term is equal to $current_term than skip marking that term.
        if ($current_term == $term->tid) {
          continue;
        }
        // Make sure the title used to populate the title attriute contains plain text.
        $term_title = drupal_html_to_text($term->description);
        $fragment = NULL;
        if (!empty($vids) && (variable_get('lexicon_click_option', 0) == 1)) {
          if (variable_get('lexicon_hide_if_empty', 1) && empty($term_title)) {
            continue;
          }
          if (variable_get('lexicon_page_per_letter', FALSE)) {
            $linkto = variable_get('lexicon_path_' . $term->vid, 'lexicon/' . $term->vid) . '/letter_' . drupal_strtolower(drupal_substr($term->name, 0, 1));
          }
          else {
            $linkto = variable_get('lexicon_path_' . $term->vid, 'lexicon/' . $term->vid);
          }

          //Make sure the id of the anchor is a valid one and does not contain illegal characters or format
          $fragment = _lexicon_create_valid_id($term->name);
        }
        else {
          $linkto = 'taxonomy/term/' . $term->tid;
        }
        $ins_before = $ins_after = NULL;
        $term_class = variable_get('lexicon_term_class', 'lexicon-term');

        // Depending on the replace mode set the $ins_before and $ins_after to be used for marking
        switch ($replace_mode) {
          case 'superscript':
            $ins_after = '<sup class="lexicon-indicator" title="' . $term_title . '">';
            if ($link_style == 'none') {
              $ins_after .= variable_get("lexicon_superscript", 'i');
            }
            else {
              $ins_after .= l(variable_get("lexicon_superscript", 'i'), $linkto,
                array('attributes' => array('title' => $term_title, 'class' => $term_class),
                'fragment' => $fragment, 'absolute' => $absolute_link));
            }
            $ins_after .= '</sup>';
            break;

          case 'abbr':
            if ($link_style == 'none') {
              $ins_before .= '<span class="' . $term_class . '" title="' . $term_title . '"><' . $replace_mode . ' title="' . $term_title . '">';
              $ins_after .= '</' . $replace_mode . '></span>';
            }
            else {
              $ins_before .= '<' . $replace_mode . ' title="' . $term_title . '"><a class="' . $term_class . '" href="' . url($linkto, array('fragment' => $fragment, 'absolute' => $absolute_link)) . '" title="' . $term_title . '">';
              $ins_after .= '</a></' . $replace_mode . '>';
            }
            break;

          case 'acronym':
          case 'cite':
          case 'dfn':
            if ($link_style == 'none') {
              $ins_after .= '</' . $replace_mode . '>';
            }
            else {
              $ins_before .= '<a class="' . $term_class . '" href="' . url($linkto, array('fragment' => $fragment, 'absolute' => $absolute_link)) . '">';
              $ins_after .= '</' . $replace_mode . '></a>';
            }
            $ins_before .= '<' . $replace_mode . ' title="' . $term_title . '">';
            break;

          case 'iconterm':
            // Icon format, plus term link.
            $img = '<img src="' . base_path() . variable_get("lexicon_icon", '/imgs/lexicon.gif') . "\" />";
            if ($link_style == 'none') {
              $ins_after .= $img;
            }
            else {
              $ins_before .= '<a class="' . $term_class . '" href="' . url($linkto, array('fragment' => $fragment, 'absolute' => $absolute_link)) . '" title="' . $term_title . '">';
              $ins_after = $img . '</a>';
            }
            break;

          case 'icon':
            // Icon format.
            $img = '<img src="' . base_path() . variable_get("lexicon_icon", '/imgs/lexicon.gif') . "\" />";
            if ($link_style == 'none') {
              $ins_after .= $img;
            }
            else {
              $ins_after = l($img, $linkto, array('attributes' => array('title' => $term_title, 'class' => 'lexicon-icon'), 'fragment' => $fragment, 'absolute' => $absolute_link, 'html' => TRUE));
            }
            break;

            case 'term':
            // Term format.
            if ($link_style == 'none') {
              $ins_before = '<span class="' . $term_class . '">';
              $ins_after = '</span>';
            }
            else {
              $ins_before = '<a class="' . $term_class . '" href="' . url($linkto, array('fragment' => $fragment, 'absolute' => $absolute_link)) . '" title="' . $term_title . '">';
              $ins_after = '</a>';
            }
            break;
          default:
            break;
        }

        if ($replace_mode == 'template') {
          // Set the information needed by the template.
          $terms_replace[] = array(
            'term' => $term,
            'absolute_link' => $absolute_link,
            'linkto' => $linkto,
            'fragment' => $fragment,
            'term_class' => $term_class,
            );
        }
        else {
          // Set just the information needed for the preset marking option.
          $terms_replace[] = array(
            'term' => $term,
            'ins_before' => $ins_before,
            'ins_after' => $ins_after,
            );
        }
      }
    }
    return _lexicon_insertlink($text, $terms_replace);
  }
  return $text;
}

/**
 * Insert lexicon links to $text after every matching $terms[i]['synonyms'] that is not inside a blocking tag.
 * $terms[i]['ins_before'] is prepended to the matches, $terms[i]['ins_after'] is appended to them.
 * Match type and replace mode all depend on user settings.
 * The text is scanned once for all blocking tags and matches, then those 'events' are sorted and handled one by one.
 */
function _lexicon_insertlink(&$text, &$terms_replace) {
  $multibyte_enabled = extension_loaded('mbstring');
  if ($multibyte_enabled) {
    $mb_prefix = 'mb_';
  }
  else {
    $mb_prefix = NULL;
  }
  $case_sensitive = variable_get("lexicon_case", '1');
  $findfunc = $mb_prefix . 'strpos';
  $findtagfunc = $mb_prefix . 'strpos';

  $replaceall = variable_get("lexicon_replace_all", 0);
  $replace_mode = variable_get("lexicon_replace", 'superscript');

  $events = array();

  // Find blocking tags.
  $open_tags = array('[no-lexicon]', '<', '<a ', '[code');
  $close_tags = array('[/no-lexicon]', '>', '</a>', '[/code]');

  $user_tags = explode(' ', variable_get("lexicon_blocking_tags", 'abbr acronym'));
  foreach ($user_tags as $tag) {
    if (!empty($tag)) {
      if (ctype_alnum($tag)) {
        $open_tags[] = "<$tag";
        $close_tags[] = "</$tag>";
      }
      elseif ($tag[0] == '.') {
        $open_tags[] = '<span class="' . drupal_substr($tag, 1);
        $close_tags[] = "</span>";
      }
    }
  }

  $searchtext = $case_sensitive ? $text : drupal_strtolower($text);

  foreach ($open_tags as $i => $tag) {
    $offset = 0;
    while (($offset = $findtagfunc($searchtext, $tag, $offset)) !== FALSE) {
      // Longer tags will override shorter '<' on the same offset.
      $events[$offset] = array('type' => 'open', 'which' => $i);
      $offset += drupal_strlen($tag);
    }
  }

  // Find match candidates.
  foreach ($terms_replace as $i => $term) {
    $name = $term['term']->name;
    // Search for term name in content.
    if (!$case_sensitive) {
        $name = drupal_strtolower($name);
    }
    $offset = 0;
    $first_match_found = FALSE;
    while (($offset = $findfunc($searchtext, $name, $offset)) !== FALSE) {
      $len = drupal_strlen($name);
      $match = drupal_substr($text, $offset, $len);
      //Check if the match that was found is a proper match according to the match setting
      $matchlen = drupal_strlen($match);
      $proper_match = FALSE;
      switch (variable_get("lexicon_match", 'b')) {
        case 'lr': // Require word break left or right.
          $proper_match = (_lexicon_is_boundary(drupal_substr($text, $offset - 1, 1)) || _lexicon_is_boundary(drupal_substr($text, $offset + $matchlen, 1 )));
          break;
        case 'b': // Require word break left and right.
          $proper_match = (_lexicon_is_boundary(drupal_substr($text, $offset - 1, 1)) && _lexicon_is_boundary(drupal_substr($text, $offset + $matchlen, 1)));
          break;
        case 'l': // Require word break left.
          $proper_match = _lexicon_is_boundary(drupal_substr($text, $offset - 1, 1));
          break;
        case 'r': // Require word break right.
          $proper_match = _lexicon_is_boundary(drupal_substr($text, $offset + $matchlen, 1));
          break;
        case 's': // Match any substring.
        default:
          $proper_match = TRUE;
          break;
      }
      if ($proper_match) {
        // Only longer matches override shorter ones.
        if (!isset($events[$offset]) || drupal_strlen($events[$offset]['match']) < drupal_strlen($match)) {
          // Get synonym with case as in text.
          $events[$offset] = array('type' => 'match', 'which' => $i, 'match' => $match);
          if (!$replaceall) {
            $first_match_found = TRUE;
            break;
          }
        }
      }
      $offset += $len;
    }

    if (isset($term['term']->synonyms)) {
      foreach ($term['term']->synonyms as $synonym) {
        if (!$case_sensitive) {
          $synonym = drupal_strtolower($synonym);
        }
        $offset = 0;
        $first_match_found = FALSE;
        while (($offset = $findfunc($searchtext, $synonym, $offset)) !== FALSE) {
          $len = drupal_strlen($synonym);
          $match = drupal_substr($text, $offset, $len);
          //Check if the match that was found is a proper match according to the match setting
          $matchlen = drupal_strlen($match);
          $proper_match = FALSE;
          switch (variable_get("lexicon_match", 'b')) {
            case 'lr': // Require word break left or right.
              $proper_match = (_lexicon_is_boundary(drupal_substr($text, $offset - 1, 1)) || _lexicon_is_boundary(drupal_substr($text, $offset + $matchlen, 1 )));
              break;
            case 'b': // Require word break left and right.
              $proper_match = (_lexicon_is_boundary(drupal_substr($text, $offset - 1, 1)) && _lexicon_is_boundary(drupal_substr($text, $offset + $matchlen, 1)));
              break;
             case 'l': // Require word break left.
              $proper_match = _lexicon_is_boundary(drupal_substr($text, $offset - 1, 1));
              break;
            case 'r': // Require word break right.
              $proper_match = _lexicon_is_boundary(drupal_substr($text, $offset + $matchlen, 1));
              break;
            case 's': // Match any substring.
            default:
              $proper_match = TRUE;
              break;
          }
          if ($proper_match) {
            // Only longer matches override shorter ones.
            if (!isset($events[$offset]) || drupal_strlen($events[$offset]['match']) < drupal_strlen($match)) {
              // Get synonym with case as in text.
              $events[$offset] = array('type' => 'match', 'which' => $i, 'match' => $match);
              if (!$replaceall) {
                $first_match_found = TRUE;
                break;
              }
            }
          }
          $offset += $len;
        }
        if ($first_match_found && !$replaceall) {
          break;
        }
      }
    }
  }

  ksort($events);

  $newtext = '';
  $parsed = 0; // Text was parsed from chars 0 to $parsed (exclusive).
  foreach ($events as $place => $event) {
    // Skip events inside blocking tag (they're already copied as is).
    if ($place < $parsed) {
      continue;
    }
    // Copy plain text (with no events).
    $newtext .= drupal_substr($text, $parsed, ($place - $parsed));
    $parsed = $place;
    // If a blocking tag is opened, skip to closing tag.
    if ($event['type'] == 'open') {
      $skip = $findtagfunc($text, $close_tags[$event['which']], $place);
      if ($skip === FALSE) {
        $skip = drupal_strlen($text);
      }
      // If the tag is [no-lexicon] - remove it with the closing tag (by incrementing $parsed without copying).
      if ($event['which'] == 0) {
        $parsed += drupal_strlen($open_tags[$event['which']]);
        $newtext .= drupal_substr($text, $parsed, ($skip - $parsed));
        $parsed = $skip + drupal_strlen($close_tags[$event['which']]);
      }
      // Copy text without changing it.
      else {
        $newtext .= drupal_substr($text, $parsed, ($skip - $parsed));
        $parsed = $skip;
      }
    }
    if ($event['type'] == 'match') {
      $matchlen = drupal_strlen($event['match']);
      if ($replace_mode == 'template') {
        $newtext .= theme('lexicon_mark_term', array('term' => $terms_replace[$event['which']], 'text' => $event['match']));
      }
      else {
        $newtext .= $terms_replace[$event['which']]['ins_before'] . $event['match'] . $terms_replace[$event['which']]['ins_after'];
      }
      $parsed += $matchlen;
    }
  }
  // Append remaining part.
  return $newtext . drupal_substr($text, $parsed);
}

/**
 * Function that returns all Lexicon terms and synonyms from the Lexicon vocabularies indicated by $vids
 */
function _lexicon_get_terms(&$vids) {
  static $got = array();
  $terms = array();
  // If the terms have not been loaded yet get the tree for each lexicon vocabulary
  if (!$got) {
    foreach ($vids as $vid) {
      // Load the entire vocabulary with all entities
      $tree = taxonomy_get_tree($vid, 0, NULL, TRUE);
      // Add extra information to each term in the tree
      foreach ($tree as $term) {
        _lexicon_term_add_info($term);
        $terms[] = $term;
      }
    }
    $got = $terms;
  }
  else {
    // Use the already loaded terms
    $terms = $got;
  }
  return $terms;
}

/**
 * Lexicon function to add extra information to a term object.
 */
function _lexicon_term_add_info(&$term) {
  // Check if the info has already been set
  if (!isset($term->info_added)) {
    global $base_url;

    $destination = drupal_get_destination();
    static $click_option, $link_related, $image_field, $synonyms_field, $page_per_letter, $show_edit, $show_desc, $show_search, $edit_voc, $access_search;
    if (!isset($click_option)) {
      $click_option = variable_get('lexicon_click_option', 0);
      $link_related = variable_get('lexicon_link_related', TRUE);
      $image_field = variable_get('lexicon_image_field_' . $term->vid, "");
      $synonyms_field = variable_get("lexicon_synonyms_field_" . $term->vid, "");
      $page_per_letter = variable_get('lexicon_page_per_letter', FALSE);
      $show_edit = variable_get('lexicon_show_edit', TRUE);
      $show_search = variable_get('lexicon_show_search', TRUE);
      $edit_voc = user_access('edit terms in ' . $term->vid);
      $access_search = user_access('search content');
    }

    // Set the id for the term
    $term->id = _lexicon_create_valid_id($term->name);

    // If there is an image for the term add the image information to the $term object.
    if (isset($term->$image_field)) {
      $images = $term->$image_field;
      if (!empty($images)) {
        $term->image["uri"] = $images["und"][0]["uri"];
        $term->image["alt"] = check_plain($images["und"][0]["alt"]);
        $term->image["title"] = check_plain($images["und"][0]["title"]);
      }
    }

    $path = variable_get('lexicon_path_' . $term->vid, 'lexicon/' . $term->vid);
    // If the Lexicon is spread over seperate pages per letter the link must be to the appropriate page with the correct anchor.
    if ($page_per_letter) {
      $term->link["path"] = $path . '/letter_' . drupal_strtolower(drupal_substr($term->name, 0, 1));
    }
    // If the Lexicon overview shows all letters on one page the link must be to the appropriate anchor.
    else {
      $term->link["path"] = $path;
    }
    $term->link["fragment"] = _lexicon_create_valid_id($term->name);

    // If there are related terms add the information of each related term to the $term object.
    if ($relations = _lexicon_get_related_terms($term)) {
      foreach ($relations as $related) {
        $term->related[$related->tid]["name"] = check_plain($related->name);
        $related_path = variable_get('lexicon_path_' . $related->vid, 'lexicon/' . $related->vid);
        // If the related terms have to be linked add the link information
        if ($link_related) {
          if ($click_option == 1) {
            // The link has to point to the term on the Lexicon page.
              if ($page_per_letter) {
                $term->related[$related->tid]["link"]["path"] = $related_path . '/letter_' . drupal_strtolower(drupal_substr($related->name, 0, 1));
              }
              // If the Lexicon overview shows all letters on one page the link must be to the appropriate anchor.
              else {
                $term->related[$related->tid]["link"]["path"] = $related_path;
            }
            $term->related[$related->tid]["link"]["fragment"] = _lexicon_create_valid_id($related->name);
          }
          else {
            // The link has to point to the page of the term itself.
            $term->related[$related->tid]["link"]["path"] = $related_path . '/term/' . $related->tid;
            $term->related[$related->tid]["link"]["fragment"] = '';
          }
        }
      }
    }

    // If there are synonyms add them to the $term object
    if (isset($term->$synonyms_field)) {
      $synonyms = $term->$synonyms_field;
      if (!empty($synonyms)) {
        foreach ($synonyms["und"] as $synonym) {
          $term->synonyms[] = $synonym["safe_value"];
        }
      }
    }

    if ($show_edit && $edit_voc) {
      $term->extralinks['edit term']["name"] = t('edit term');
      $term->extralinks['edit term']["path"] = 'taxonomy/term/' . $term->tid . '/edit';
      $term->extralinks['edit term']["attributes"] = array(
        'class' => 'lexicon-edit-term',
        'title' => t('edit this term and definition'),
        'query' => $destination,
      );
    }

    if ($show_search && $access_search) {
      $term->extralinks['search for term']["name"] = t('search for term');
      $term->extralinks['search for term']["path"] = 'search/node/' . $term->name;
      $term->extralinks['search for term']["attributes"] = array(
        'class' => 'lexicon-search-term',
        'title' => t('search for content using this term'),
        'query' => $destination,
      );
    }

    $term->info_added = TRUE;
  }
  return $term;
}

/**
 * Get all synonyms for all lexicon terms in a specific vocabulary.
 */
function _lexicon_get_synonyms($vid) {
  $synonyms = array();
  $tax_tree = taxonomy_get_tree($vid, 0, NULL, TRUE);

  $synonyms_field = variable_get("lexicon_synonyms_field_" . $vid, "");

  foreach ($tax_tree as $term) {
    $syn_array = array();
    if (isset($term->$synonyms_field)) {
      $syn_array = $term->$synonyms_field;
    }
    if (!empty($syn_array)) {
      foreach ($syn_array["und"] as $synonym) {
        $synonyms[$term->tid][] = $synonym["safe_value"];
      }
    }
  }
  return $synonyms;
}

/**
 * Find all term objects related to a given term ID.
 *
 * @param $term
 *   the term for which to get related items
 * @return
 *   an array related-tid => related-term
 *
 */
function _lexicon_get_related_terms(&$term) {
  $related = array();

  $related_term_field = variable_get("lexicon_related_terms_field_" . $term->vid, "");

  $related_terms = array();
  if (isset($term->$related_term_field)) {
    $related_terms = $term->$related_term_field;
  }
  if (!empty($related_terms)) {
    foreach ($related_terms["und"] as $related_term) {
      $related_tid = $related_term["tid"];
      $related[$related_tid] = taxonomy_term_load($related_tid);
    }
  }
  return $related;
}

/**
 * Function that returns the default alphabar instruction based on the page per letter setting.
 */
function _lexicon_alphabar_instruction_default() {
  if (variable_get('lexicon_page_per_letter', FALSE)) {
    return t('Click one of the letters above to be taken to a page of all terms beginning with that letter.');
  }
  else {
    return t('Click one of the letters above to advance the page to terms beginning with that letter.');
  }
}

function _lexicon_is_boundary($char) {
  if (extension_loaded('mbstring')) {
    return (mb_strpos("!\"#\$%&'()*+,-./:;<=>?@[\]^_`{|}~� ��������� \t\n\r", $char) !== FALSE);
  }
  else {
    return (strpos("!\"#\$%&'()*+,-./:;<=>?@[\]^_`{|}~� ��������� \t\n\r", $char) !== FALSE);
  }
}

/**
 * Function that resturns a valid id to be used as anchor-id based on the name that is supplied to the function.
 */
function _lexicon_create_valid_id($name) {
  $allowed_chars = '-A-Za-z0-9._:';
  $id = preg_replace(
    array(
      '/&nbsp;|\s/',
      '/\'/',
      '/&mdash;/',
      '/&amp;/',
      '/&[a-z]+;/',
      '/[^' . $allowed_chars . ']/',
      '/^[-0-9._:]+/',
      '/__+/',
    ),
    array(
      '_',     // &nbsp; and spaces
      '-',     // apostrophe, so it makes things slightly more readable
      '--',    // &mdash;
      'and',   // &amp;
      '',      // any other entity
      '',      // any character that is invalid as an ID name
      '',      // any digits at the start of the name
      '_',     // reduce multiple underscores to just one
    ),
    strip_tags($name)
    );
  return $id;
}

/**
 * Function to clear the filter cache.
 */
function _lexicon_clear_filter_cache($vid = NULL, $force = FALSE) {
  // Only clear the filter cache if the vocabulary is used as a Lexicon or when the clearing of the filter cache is forced (from the admin form submit).
  if (in_array($vid, $vids = variable_get('lexicon_vids', array())) || $force ) {
    // We could throw less things away if we checked which filter formats
    // used the lexicon filter, and we only threw those away. In practice,
    // most if not all formats would use the lexicon filter, so we just
    // get rid of them all.
    cache_clear_all('*', 'cache_filter', TRUE);
    drupal_set_message(t('The filter cache has been cleared. There may be a temporary performance degradation while it is rebuilt.'));
  }
}

/**
 * Function to clear the menu cache.
 */
function _lexicon_clear_menu_cache() {
  menu_rebuild();
  drupal_set_message(t('The menu cache has been cleared. There may be a temporary performance degradation while it is rebuilt.'));
}
